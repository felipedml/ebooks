"use client";

import { useState, useCallback, useEffect, useMemo, useRef } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { Check, ChevronsRight } from "lucide-react";
import { useReducedMotion } from "./hooks/useReducedMotion";
import { Textarea } from "@/components/ui/textarea";
import FluxoDinamico from "@/components/FluxoDinamico";

/**
 * InteractiveChat ‚Äî GPT‚Äëlike, super clean (Light) + Full‚ÄëHeight
 *
 * Fluxo de exemplo pedido:
 * 1) Briefing (perguntas)
 * 2) Sum√°rio proposto
 * 3) Checkout/pagamento
 * 4) Gera√ß√£o do livro (~100 p√°ginas) com cap√≠tulos sequenciais
 * 5) Capa criada por IA (ex: Canva)
 */

// ---------- Types ----------

type ChatOption = { id: string; label: string; value: string };

type ChatPiece =
  | { kind: "text"; text: string; delayMs?: number }
  | { kind: "options"; options: ChatOption[] };

export type InteractiveChatProps = {
  agentName?: string;
  avatarUrl?: string;
  script?: ChatPiece[];
  onOptionSelect?: (value: string, option: ChatOption) => void;
  typingSpeed?: number;
  bubbleMaxWidthClass?: string;
  className?: string;
};

// ---------- Utils ----------

function clsx(...parts: Array<string | false | null | undefined>) {
  return parts.filter(Boolean).join(" ");
}

// Normalize quebras de linha (Windows/Unix) e evita dividir incorretamente
function splitLines(text: string): string[] {
  return text.split(/\r?\n/);
}

function TextBlock({ text }: { text: string }) {
  // preserva quebras de linha no <p>
  const lines = splitLines(text);
  return (
    <p className="text-[15px] md:text-base leading-7 text-neutral-900">
      {lines.map((line, i) => (
        <span key={i}>
          {line}
          {i < lines.length - 1 && <br />}
        </span>
      ))}
    </p>
  );
}

// ---------- Constants ----------

const FALLBACK_AVATAR =
  "/unnamed.jpg";

// ---------- Minimal UI bits ----------

function UIButton({
  children,
  onClick,
  className,
  disabled,
  ariaLabel,
  type = "button",
}: {
  children: React.ReactNode;
  onClick?: () => void;
  className?: string;
  disabled?: boolean;
  ariaLabel?: string;
  type?: "button" | "submit" | "reset";
}) {
  return (
    <button
      type={type}
      aria-label={ariaLabel}
      disabled={disabled}
      onClick={onClick}
      className={clsx(
        "inline-flex cursor-pointer select-none items-center justify-center gap-2 rounded-full px-4 py-2 text-sm font-semibold whitespace-nowrap",
        "border transition focus:outline-none focus-visible:ring-2 focus-visible:ring-emerald-500",
        className
      )}
    >
      {children}
    </button>
  );
}

function AgentRow({
  avatarUrl,
  children,
  bubbleMaxWidthClass,
}: {
  avatarUrl?: string;
  children: React.ReactNode;
  bubbleMaxWidthClass: string;
}) {
  const src = avatarUrl || FALLBACK_AVATAR;
  return (
    <div className="flex w-full items-start gap-3">
      <div className="relative inline-flex h-10 w-10 shrink-0 select-none items-center justify-center overflow-hidden rounded-full bg-neutral-200 ring-1 ring-black/5">
        {/* eslint-disable-next-line @next/next/no-img-element */}
        <img src={src} alt="" className="h-full w-full object-cover" />
      </div>
      <div
        className={clsx(
          "rounded-xl border border-neutral-200 bg-white px-4 py-3 md:px-5 md:py-4 text-neutral-900",
          bubbleMaxWidthClass
        )}
      >
        {children}
      </div>
    </div>
  );
}

function TypingDots() {
  return (
    <div aria-label="Digitando" role="status" className="flex items-center gap-1 text-neutral-400">
      <span className="sr-only">Digitando‚Ä¶</span>
      <span className="h-1.5 w-1.5 animate-bounce rounded-full bg-current [animation-delay:-0.2s]" />
      <span className="h-1.5 w-1.5 animate-bounce rounded-full bg-current" />
      <span className="h-1.5 w-1.5 animate-bounce rounded-full bg-current [animation-delay:0.2s]" />
    </div>
  );
}

// ---------- Helpers (business logic) ----------

type Brief = { tema?: string; publico?: string; tom?: string };

function makeToc(brief: Brief) {
  const tema = brief.tema || "Tema";
  const publico = brief.publico || "leitores";
  const tom = brief.tom || "pr√°tico";
  return (
    `Sum√°rio sugerido (tom ${tom}, para ${publico}):\n` +
    `1. Introdu√ß√£o a ${tema}\n` +
    `2. Fundamentos essenciais\n` +
    `3. Ferramentas e conceitos-chave\n` +
    `4. Estruturando sua base em ${tema}\n` +
    `5. M√©todos e boas pr√°ticas\n` +
    `6. Estudos de caso\n` +
    `7. Erros comuns e como evitar\n` +
    `8. Estrat√©gias avan√ßadas\n` +
    `9. Implementa√ß√£o passo a passo\n` +
    `10. Medindo resultados\n` +
    `11. Pr√≥ximos passos e roadmap\n` +
    `12. Conclus√£o`
  );
}

function makeChapterBursts(total = 10) {
  const arr: ChatPiece[] = [];
  arr.push({ kind: "text", text: "Pagamento aprovado ‚úÖ", delayMs: 500 });
  arr.push({ kind: "text", text: "Iniciando gera√ß√£o do livro (~100 p√°ginas)‚Ä¶", delayMs: 600 });
  for (let i = 1; i <= total; i++) {
    arr.push({ kind: "text", text: `Gerando Cap√≠tulo ${i}/${total}‚Ä¶`, delayMs: 300 });
  }
  arr.push({ kind: "text", text: "Livro gerado com sucesso!", delayMs: 700 });
  arr.push({ kind: "text", text: "Criando capa com IA (ex: Canva)‚Ä¶", delayMs: 600 });
  arr.push({
    kind: "text",
    text: "Capa pronta: t√≠tulo provis√≥rio ‚ÄòSeu Livro de ${TEMA}‚Äô, autor ‚ÄòSeu Nome‚Äô.",
    delayMs: 600,
  }); // ser√° substitu√≠do dinamicamente com o tema real
  return arr;
}

// Infer√™ncia simples a partir de texto livre para Brief (tema/p√∫blico/tom)
function inferBriefFromText(input: string): Partial<Brief> {
  const text = input.toLowerCase();
  const inferred: Partial<Brief> = {};

  // Tema
  if (/neg√≥cio|negocio|marketing|venda|gest√£|empreend/.test(text)) inferred.tema = "Neg√≥cios";
  else if (/sa√∫de|saude|fitness|nutri|medicin|bem-estar|bem estar/.test(text)) inferred.tema = "Sa√∫de";
  else if (/fic√ß|ficcao|romance|fantasia|conto|novela|hist√≥ri/.test(text)) inferred.tema = "Fic√ß√£o";

  // P√∫blico
  if (/iniciante|come√ßando|b√°sic|basico|leigo/.test(text)) inferred.publico = "Iniciantes";
  else if (/profission|expert|avan√ßad|avancad|especialist|t√©cnic/.test(text)) inferred.publico = "Profissionais";
  else if (/pais|m√£es|maes|fam√≠li|famil|matern|patern/.test(text)) inferred.publico = "Pais e m√£es";

  // Tom
  if (/pr√°tic|pratic|m√£o na massa|passo a passo/.test(text)) inferred.tom = "Pr√°tico";
  else if (/inspirador|motiv|hist√≥ria de vida|exemplo de vida/.test(text)) inferred.tom = "Inspirador";
  else if (/acad√™mic|academic|cient√≠fic|cientific|t√©cnic|teoric/.test(text)) inferred.tom = "Acad√™mico";

  return inferred;
}

// ---------- Main ----------

const DEFAULT_SCRIPT: ChatPiece[] = [
  { kind: "text", text: "Ol√°! Vamos criar seu livro em 5 passos claros.", delayMs: 450 },
  { kind: "text", text: "1) Briefing r√°pido ‚Ä¢ 2) Sum√°rio ‚Ä¢ 3) Pagamento ‚Ä¢ 4) Gera√ß√£o (~100 p√°gs) ‚Ä¢ 5) Capa por IA", delayMs: 650 },
  {
    kind: "options",
    options: [
      { id: "start", label: "Come√ßar briefing", value: "start_briefing" },
      { id: "later", label: "Depois", value: "later" },
    ],
  },
];

export default function InteractiveChat({
  onOptionSelect,
  typingSpeed = 18,
  className,
}: InteractiveChatProps) {
  const prefersReduced = useReducedMotion();
  
  // Estados para fluxo din√¢mico
  const [fluxoAtivo, setFluxoAtivo] = useState<any>(null);
  const [carregandoFluxo, setCarregandoFluxo] = useState(true);
  const [usarFluxoEstatico, setUsarFluxoEstatico] = useState(false);

  // timeline din√¢mico - Script do Bruno
  const [timeline, setTimeline] = useState<ChatPiece[]>([
    { kind: "text", text: "Ol√°, sou Bruno!", delayMs: 600 },
    { kind: "text", text: "Estou aqui para gerar seu livro e te entregar ele pronto em menos de uma hora", delayMs: 800 },
    { kind: "text", text: "Muito prazer", delayMs: 500 },
    { kind: "text", text: "Posso te apresentar uma nova forma de ganhar MUITO dinheiro que talvez voc√™ ainda n√£o conhecia antes de chegar aqui?", delayMs: 1000 },
    {
      kind: "options",
      options: [
        { id: "pode1", label: "PODE", value: "pode_apresentar" },
        { id: "pode2", label: "PODE COM CERTEZA", value: "pode_certeza" },
      ],
    },
  ]);

  // briefing state
  const [brief, setBrief] = useState<Brief>({ tema: "", publico: "", tom: "" });

  // Estados para coleta de dados do usu√°rio
  const [userData, setUserData] = useState({
    nome: "",
    titulo: "",
    subtitulo: "",
    resumo: "",
    idioma: "",
    autor: "",
    email: "",
    whatsapp: "",
  });

  // Estado para controlar qual input est√° ativo
  const [awaitingInput, setAwaitingInput] = useState<string | null>(null);

  // Estados para controle de gera√ß√£o din√¢mica
  interface DynamicQuestion {
    id: string;
    question: string;
    type: string;
    options?: string[];
  }
  const [isGeneratingQuestions, setIsGeneratingQuestions] = useState(false);
  const [dynamicQuestions, setDynamicQuestions] = useState<DynamicQuestion[]>([]);
  const [isGeneratingSummary, setIsGeneratingSummary] = useState(false);

  // Constantes do componente
  const avatarUrl = "/unnamed.jpg";
  const bubbleMaxWidthClass = "max-w-[340px] sm:max-w-[460px]";

  // Pergunta de texto (IA decide)
  const [awaitingTextQuestion, setAwaitingTextQuestion] = useState<null | { id: string; question: string }>(null);
  const [textInputValue, setTextInputValue] = useState("");

  // Respostas din√¢micas
  const [dynamicAnswers, setDynamicAnswers] = useState<Record<string, string>>({});

  // Remover l√≥gica de perguntas de texto para simplificar
  const promptNextUnansweredTextQuestion = useCallback(() => {
    return false; // Sempre retorna false para n√£o mostrar textarea
  }, []);

  // Carregar fluxo ativo ao inicializar
  useEffect(() => {
    const carregarFluxoAtivo = async () => {
      try {
        console.log('Iniciando carregamento do fluxo ativo...');
        const response = await fetch('/api/fluxo-ativo');
        
        if (!response.ok) {
          console.log('Resposta n√£o OK:', response.status, response.statusText);
          setUsarFluxoEstatico(true);
          return;
        }

        const contentType = response.headers.get('content-type');
        if (!contentType || !contentType.includes('application/json')) {
          console.log('Resposta n√£o √© JSON:', contentType);
          setUsarFluxoEstatico(true);
          return;
        }

        const data = await response.json();
        console.log('Dados recebidos:', data);
        
        if (data.success && data.fluxo) {
          console.log('Fluxo ativo encontrado:', data.fluxo.nome);
          setFluxoAtivo(data.fluxo);
        } else {
          console.log('Nenhum fluxo ativo, usando est√°tico. Raz√£o:', data.message || data.error);
          setUsarFluxoEstatico(true);
        }
      } catch (error) {
        console.error('Erro ao carregar fluxo ativo:', error);
        // Em caso de erro, usar fluxo est√°tico
        setUsarFluxoEstatico(true);
      } finally {
        setCarregandoFluxo(false);
      }
    };

    carregarFluxoAtivo();
  }, []);

  const [playedIndex, setPlayedIndex] = useState(0);
  const [typingText, setTypingText] = useState("");
  const [showOptions, setShowOptions] = useState<ChatOption[] | null>(null);
  const [userEcho, setUserEcho] = useState<string | null>(null);

  const containerRef = useRef<HTMLDivElement | null>(null);
  const currentPiece = timeline[playedIndex];

  // Auto‚Äëscroll
  useEffect(() => {
    const el = containerRef.current;
    if (!el) return;
    el.scrollTo({ top: el.scrollHeight, behavior: prefersReduced ? "auto" : "smooth" });
  }, [playedIndex, typingText, prefersReduced]);

  // Play script
  useEffect(() => {
    if (!currentPiece) return;
    if (currentPiece.kind === "text") {
      setTypingText("");
      const start = setTimeout(() => {
        let i = 0;
        const chars = currentPiece.text.split("");
        const step = () => {
          i += 1;
          setTypingText(chars.slice(0, i).join(""));
          if (i >= chars.length) {
            setTimeout(() => setPlayedIndex((v) => v + 1), 260);
            return;
          }
          const effective = Math.max(7, Math.min(typingSpeed, 28));
          timer = window.setTimeout(step, effective);
        };
        let timer = window.setTimeout(step, 0);
      }, currentPiece.delayMs ?? 380);
      return () => clearTimeout(start);
    }
    if (currentPiece.kind === "options") setShowOptions(currentPiece.options);
  }, [currentPiece, typingSpeed]);

  const inject = useCallback((pieces: ChatPiece[]) => {
    setTimeline((prev) => [...prev, ...pieces]);
  }, []);

  // Fun√ß√£o para gerar perguntas din√¢micas (tenta IA, fallback para mock)
  const generateDynamicQuestions = useCallback(async (briefing: string) => {
    setIsGeneratingQuestions(true);

    // Backup mockado
    const mockQuestions = [
      {
        id: 'q1',
        question: 'Qual √© o foco principal do seu livro?',
        type: 'multiple_choice',
        options: ['Crescimento pessoal', 'Estrat√©gias pr√°ticas', 'Hist√≥rias inspiradoras', 'Guia t√©cnico']
      },
      {
        id: 'q2',
        question: 'Quem √© seu p√∫blico-alvo?',
        type: 'multiple_choice',
        options: ['Iniciantes no assunto', 'Profissionais experientes', 'Estudantes', 'Empreendedores']
      }
    ];

    try {
      // Tentar IA primeiro
      const response = await fetch('/api/generate-questions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ briefing }),
      });

      if (response.ok) {
        const data = await response.json();
        const qs = Array.isArray(data.questions) ? data.questions : [];
        if (qs.length > 0) {
          setDynamicQuestions(qs);
          setIsGeneratingQuestions(false);
          return qs;
        }
      }
    } catch {
      console.log('IA falhou, usando backup mockado');
    }

    // Usar backup se IA falhar
    setDynamicQuestions(mockQuestions);
    setIsGeneratingQuestions(false);
    return mockQuestions;
  }, []);

  // Fun√ß√£o para gerar sum√°rio din√¢mico (tenta IA, fallback para mock)
  const generateDynamicSummary = useCallback(async (tema: string, publico: string, tom: string) => {
    setIsGeneratingSummary(true);

    try {
      const response = await fetch('/api/generate-summary', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ tema, publico, tom }),
      });

      if (response.ok) {
        const data = await response.json();
        if (data.summary) {
          setIsGeneratingSummary(false);
          return data.summary;
        }
      }
    } catch {
      console.log('IA falhou para sum√°rio, usando backup');
    }

    // Fallback sempre funciona
    const fallbackSummary = makeToc({ tema, publico, tom });
    setIsGeneratingSummary(false);
    return fallbackSummary;
  }, []);

  // Ap√≥s a gera√ß√£o de perguntas din√¢micas, continuar o fluxo quando tudo respondido
  const continueAfterDynamicIfReady = useCallback(async () => {
    // Se todas as perguntas din√¢micas foram respondidas, decide o pr√≥ximo passo
    const allAnswered = dynamicQuestions.length > 0 && dynamicQuestions.every((q: DynamicQuestion) => dynamicAnswers[q.id] !== undefined);
    if (!allAnswered) return;

    // Inferir tema/p√∫blico/tom das respostas
    const respostas = Object.values(dynamicAnswers).join(' ');
    const inferred = inferBriefFromText(respostas);

    // Definir valores padr√£o se n√£o inferidos
    const tema = brief.tema || inferred.tema || 'Neg√≥cios';
    const publico = brief.publico || inferred.publico || 'Iniciantes';
    const tom = brief.tom || inferred.tom || 'Pr√°tico';

    setBrief(prev => ({ ...prev, tema, publico, tom }));

    // Mostrar resumo das respostas primeiro
    inject([
      { kind: 'text', text: '√ìtimo! Briefing completo. Resumo:', delayMs: 400 },
      { kind: 'text', text: `üìã Tema: ${tema} | P√∫blico: ${publico} | Tom: ${tom}`, delayMs: 500 },
      { kind: 'text', text: 'Agora vou gerar um sum√°rio personalizado baseado em tudo que coletamos‚Ä¶', delayMs: 600 },
    ]);

    // Gerar sum√°rio
    const summary = await generateDynamicSummary(tema, publico, tom);
    inject([
      { kind: 'text', text: 'Sum√°rio gerado com IA:', delayMs: 600 },
      { kind: 'text', text: summary, delayMs: 500 },
      { kind: 'options', options: [{ id: 'oktoc', label: 'Aprovar sum√°rio', value: 'approve_toc' }, { id: 'edittoc', label: 'Editar sum√°rio', value: 'edit_toc' }] },
    ]);
  }, [brief, dynamicAnswers, dynamicQuestions, generateDynamicSummary, inject]);

  const handleSelect = useCallback(
    (opt: ChatOption) => {
      setShowOptions(null);
      setUserEcho(opt.label);
      onOptionSelect?.(opt.value, opt);

      // Script do Bruno - Fluxo sequencial fixo
      if (opt.value === "pode_apresentar" || opt.value === "pode_certeza") {
        inject([
          { kind: "text", text: "Maravilha, qual seu nome?", delayMs: 600 },
        ]);
        setAwaitingInput("nome");
        return;
      }

      if (opt.value === "nunca_nem_imaginei" || opt.value === "ja_sabia_sim") {
        inject([
          { kind: "text", text: "Perfeito, ent√£o pense um pouco...", delayMs: 600 },
          { kind: "text", text: "Porque ganhar dinheiro assim √© t√£o pouco conhecido?", delayMs: 800 },
          { kind: "text", text: "Qual √© a maior dificuldade de ganhar dinheiro vendendo ebooks na Amazon?", delayMs: 900 },
          { kind: "text", text: "(e nos outros sites tamb√©m, como Google Play Books, Apple Books, etc, etc, etc)", delayMs: 700 },
          { kind: "text", text: "Conseguiu chegar em alguma resposta?", delayMs: 600 },
          {
            kind: "options",
            options: [
              { id: "acho1", label: "ACHO QUE SIM", value: "acho_que_sim" },
              { id: "sim1", label: "SIM, EU SEI", value: "sim_eu_sei" },
              { id: "nao1", label: "N√ÉO FA√áO ID√âIA", value: "nao_faco_ideia" },
            ],
          },
        ]);
        return;
      }

      if (opt.value === "acho_que_sim" || opt.value === "sim_eu_sei" || opt.value === "nao_faco_ideia") {
        inject([
          { kind: "text", text: "Com certeza a maior dificuldade √© ESCREVER OS EBOOKS", delayMs: 600 },
          { kind: "text", text: "Voc√™ precisa gastar semanas, meses ou at√© ANOS em alguns casos, para escrever um livro e colocar para vender", delayMs: 1000 },
          { kind: "text", text: "E mesmo com a Intelig√™ncia Artificial, as plataformas conseguem identificar se seu ebook foi escrito por IA ou por um humano", delayMs: 1200 },
          { kind: "text", text: "E se pegarem que foi escrito por IA podem at√© bloquear sua conta...", delayMs: 800 },
          { kind: "text", text: "Mas isso n√£o precisa te desanimar, porque a gente criou uma IA que escreve 100% COM LINGUAGEM DE UM SER HUMANO", delayMs: 1200 },
          { kind: "text", text: "E voc√™ pode publicar DEZENAS de livros por semana, se quiser...", delayMs: 800 },
          { kind: "text", text: "Quer saber como funciona?", delayMs: 600 },
          {
            kind: "options",
            options: [
              { id: "quero1", label: "Quero sim !", value: "quero_saber" },
            ],
          },
        ]);
        return;
      }

      if (opt.value === "quero_saber") {
        inject([
          { kind: "text", text: "Quer gerar o seu livro agora e come√ßar a ganhar dinheiro colocando para vender nas plataformas?", delayMs: 800 },
          {
            kind: "options",
            options: [
              { id: "quero2", label: "QUERO MEU LIVRO", value: "quero_livro" },
            ],
          },
        ]);
        return;
      }

      if (opt.value === "quero_livro") {
        inject([
          { kind: "text", text: "Perfeito, ent√£o vamos come√ßar!", delayMs: 500 },
          { kind: "text", text: "Vou escrever UM LIVRO COMPLETO PARA VOC√ä, DO ZERO, COM 100% DOS DIREITOS AUTORAIS SEUS, EM MENOS DE 1 HORA POR 49,90...", delayMs: 1200 },
          { kind: "text", text: "√â isso ai, em menos de uma hora voc√™ vai ter em m√£os seu livro digital com aproximadamente 100 a 130 p√°ginas A4...", delayMs: 1000 },
          { kind: "text", text: "Escrito palavra por palavra...", delayMs: 600 },
          { kind: "text", text: "Seguindo exatamente tudo que voc√™ quiser que tenha de conte√∫do nele!", delayMs: 800 },
          { kind: "text", text: "E voc√™ ter√° 100% dos direitos autorais para fazer o que quiser!", delayMs: 700 },
          { kind: "text", text: "Vamos come√ßar?", delayMs: 500 },
          {
            kind: "options",
            options: [
              { id: "vamos1", label: "VAMOS, QUERO FAZER!", value: "vamos_fazer" },
            ],
          },
        ]);
        return;
      }

      if (opt.value === "vamos_fazer") {
        inject([
          { kind: "text", text: `Muito bom ${userData.nome}!`, delayMs: 500 },
          { kind: "text", text: "Voc√™ j√° tem a ideia de livro que quer gerar?", delayMs: 600 },
          { kind: "text", text: "Como t√≠tulo, subt√≠tulo e o conte√∫do que quer no livro...", delayMs: 700 },
          {
            kind: "options",
            options: [
              { id: "ja1", label: "JA TENHO A IDEIA COMPLETA", value: "ja_tenho_ideia" },
              { id: "ajude1", label: "ME AJUDE A FAZER", value: "me_ajude" },
            ],
          },
        ]);
        return;
      }

      if (opt.value === "ja_tenho_ideia" || opt.value === "me_ajude") {
        inject([
          { kind: "text", text: "Certo", delayMs: 400 },
          { kind: "text", text: "Qual t√≠tulo do livro? (Em poucas palavras)", delayMs: 600 },
          { kind: "text", text: "(Ex: O Clube das 5 da Manh√£)", delayMs: 500 },
        ]);
        setAwaitingInput("titulo");
        return;
      }

      if (opt.value === "portugues" || opt.value === "ingles") {
        setUserData(prev => ({ ...prev, idioma: opt.label }));
        inject([
          { kind: "text", text: "Nome do autor:", delayMs: 500 },
        ]);
        setAwaitingInput("autor");
        return;
      }

      if (opt.value === "tudo_certo" || opt.value === "tem_erro") {
        if (opt.value === "tudo_certo") {
          // Salvar dados no banco
          inject([
            { kind: "text", text: "Salvando seus dados...", delayMs: 400 },
          ]);
          
          fetch('/api/salvar-livro', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(userData),
          })
          .then(response => response.json())
          .then(data => {
            if (data.success) {
              inject([
                { kind: "text", text: "‚úÖ Dados salvos com sucesso!", delayMs: 500 },
                { kind: "text", text: "Perfeito! Vamos seguir!", delayMs: 600 },
                { kind: "text", text: "Vou te redirecionar para o link de pagamento...", delayMs: 800 },
                { kind: "text", text: `üí∞ Valor: R$ ${data.livro.valor.toFixed(2).replace('.', ',')}`, delayMs: 600 },
                { kind: "text", text: "üîó Redirecionando para pagamento seguro...", delayMs: 1000 },
                { kind: "text", text: "Obrigado pela confian√ßa! Seu livro ser√° gerado assim que o pagamento for confirmado.", delayMs: 1200 },
              ]);
            } else {
              inject([
                { kind: "text", text: "‚ùå Erro ao salvar dados. Tente novamente.", delayMs: 500 },
                { kind: "text", text: "Qual seu nome?", delayMs: 600 },
              ]);
              setAwaitingInput("nome");
            }
          })
          .catch(error => {
            console.error('Erro ao salvar:', error);
            inject([
              { kind: "text", text: "‚ùå Erro de conex√£o. Tente novamente.", delayMs: 500 },
              { kind: "text", text: "Qual seu nome?", delayMs: 600 },
            ]);
            setAwaitingInput("nome");
          });
        } else {
          inject([
            { kind: "text", text: "Sem problemas! Vamos corrigir os dados.", delayMs: 500 },
            { kind: "text", text: "Qual seu nome?", delayMs: 600 },
          ]);
          setAwaitingInput("nome");
        }
        return;
      }

      // Capturar resposta de pergunta din√¢mica (multiple_choice)
      const dyn = dynamicQuestions.find((q: DynamicQuestion) => opt.value.startsWith(`${q.id}_`));
      if (dyn) {
        setDynamicAnswers((prev) => {
          const newAnswers = { ...prev, [dyn.id]: opt.label };
          console.log('Respostas atuais:', newAnswers);
          console.log('Total de perguntas:', dynamicQuestions.length);
          console.log('Respostas dadas:', Object.keys(newAnswers).length);

          // Se j√° tem 1 ou mais respostas, ir direto para o sum√°rio (simplificar)
          if (Object.keys(newAnswers).length >= 1) {
            setTimeout(() => {
              inject([
                { kind: 'text', text: 'Perfeito! Tenho informa√ß√µes suficientes.', delayMs: 400 },
                { kind: 'text', text: 'Vou gerar um sum√°rio personalizado agora...', delayMs: 600 },
              ]);

              // Definir briefing padr√£o e gerar sum√°rio
              const tema = 'Neg√≥cios';
              const publico = 'Iniciantes';
              const tom = 'Pr√°tico';
              setBrief(prev => ({ ...prev, tema, publico, tom }));

              generateDynamicSummary(tema, publico, tom).then((summary) => {
                inject([
                  { kind: 'text', text: 'Sum√°rio gerado:', delayMs: 600 },
                  { kind: 'text', text: summary, delayMs: 500 },
                  { kind: 'options', options: [{ id: 'oktoc', label: 'Aprovar sum√°rio', value: 'approve_toc' }, { id: 'edittoc', label: 'Editar sum√°rio', value: 'edit_toc' }] },
                ]);
              });
            }, 800);
          }

          return newAnswers;
        });
        return;
      }

      // Capturar respostas de fallback (quando n√£o encontra pergunta din√¢mica espec√≠fica)
      if (opt.value.startsWith("pergunta_") || opt.value.includes("continuar") || opt.value.includes("prosseguir") || opt.value.includes("avancar")) {
        const questionNumber = opt.value.includes("1") ? "pergunta_1" :
          opt.value.includes("2") ? "pergunta_2" :
            opt.value.includes("3") ? "pergunta_3" : `fallback_${Date.now()}`;

        setDynamicAnswers((prev) => {
          const newAnswers = { ...prev, [questionNumber]: opt.label };
          console.log('Resposta de fallback capturada:', newAnswers);

          // Contar respostas ap√≥s a atualiza√ß√£o (n√£o usado mas mantido para debug)

          // Ir direto para o sum√°rio ap√≥s qualquer resposta (simplificar)
          setTimeout(() => {
            inject([
              { kind: 'text', text: 'Perfeito! Tenho informa√ß√µes suficientes.', delayMs: 400 },
              { kind: 'text', text: 'Vou gerar um sum√°rio personalizado agora...', delayMs: 600 },
            ]);

            // Definir briefing padr√£o e gerar sum√°rio
            const tema = 'Neg√≥cios';
            const publico = 'Iniciantes';
            const tom = 'Pr√°tico';
            setBrief(prev => ({ ...prev, tema, publico, tom }));

            generateDynamicSummary(tema, publico, tom).then((summary) => {
              inject([
                { kind: 'text', text: 'Sum√°rio gerado:', delayMs: 600 },
                { kind: 'text', text: summary, delayMs: 500 },
                { kind: 'options', options: [{ id: 'oktoc', label: 'Aprovar sum√°rio', value: 'approve_toc' }, { id: 'edittoc', label: 'Editar sum√°rio', value: 'edit_toc' }] },
              ]);
            });
          }, 800);

          return newAnswers;
        });
        return;
      }

      // roteador do fluxo
      if (opt.value === "start_briefing" || opt.value === "later") {
        inject([
          { kind: "text", text: "Briefing r√°pido: vou gerar perguntas personalizadas para seu livro.", delayMs: 500 },
          { kind: "text", text: "Analisando seu perfil para criar perguntas relevantes...", delayMs: 600 },
        ]);

        // Gerar perguntas din√¢micas (mockadas)
        generateDynamicQuestions("Usu√°rio iniciou briefing para cria√ß√£o de livro").then((questions) => {
          // Criar pe√ßas din√¢micas para as perguntas
          const dynamicPieces: ChatPiece[] = [];

          if (Array.isArray(questions) && questions.length > 0) {
            questions.forEach((question: DynamicQuestion, index: number) => {
              if (question && question.question) {
                dynamicPieces.push({
                  kind: "text",
                  text: `Pergunta ${index + 1}/${questions.length} ‚Äî ${question.question}`,
                  delayMs: 500
                });

                // Se tem op√ß√µes, usar as da IA
                if (Array.isArray(question.options) && question.options.length > 0) {
                  const options: ChatOption[] = question.options.map((option: string, optIndex: number) => ({
                    id: `${question.id}_${optIndex}`,
                    label: option,
                    value: `${question.id}_${option.toLowerCase().replace(/\s+/g, '_')}`
                  }));

                  dynamicPieces.push({
                    kind: "options",
                    options
                  });
                } else {
                  // Se n√£o tem op√ß√µes (pergunta de texto), criar op√ß√µes baseadas no contexto da pergunta
                  let contextualOptions: ChatOption[] = [];

                  // Detectar tipo de pergunta e criar op√ß√µes relevantes
                  const questionText = question.question.toLowerCase();

                  if (questionText.includes('p√∫blico') || questionText.includes('alvo')) {
                    contextualOptions = [
                      { id: `${question.id}_0`, label: "Iniciantes no assunto", value: `${question.id}_iniciantes` },
                      { id: `${question.id}_1`, label: "Profissionais experientes", value: `${question.id}_profissionais` },
                      { id: `${question.id}_2`, label: "Estudantes", value: `${question.id}_estudantes` },
                      { id: `${question.id}_3`, label: "P√∫blico geral", value: `${question.id}_geral` },
                    ];
                  } else if (questionText.includes('escopo') || questionText.includes('conte√∫do')) {
                    contextualOptions = [
                      { id: `${question.id}_0`, label: "Conceitos b√°sicos", value: `${question.id}_basicos` },
                      { id: `${question.id}_1`, label: "Aplica√ß√£o pr√°tica", value: `${question.id}_pratica` },
                      { id: `${question.id}_2`, label: "Teoria avan√ßada", value: `${question.id}_avancada` },
                      { id: `${question.id}_3`, label: "Casos de estudo", value: `${question.id}_casos` },
                    ];
                  } else if (questionText.includes('tom') || questionText.includes('formato') || questionText.includes('estilo')) {
                    contextualOptions = [
                      { id: `${question.id}_0`, label: "Pr√°tico e direto", value: `${question.id}_pratico` },
                      { id: `${question.id}_1`, label: "Inspirador", value: `${question.id}_inspirador` },
                      { id: `${question.id}_2`, label: "Acad√™mico", value: `${question.id}_academico` },
                      { id: `${question.id}_3`, label: "Conversacional", value: `${question.id}_conversacional` },
                    ];
                  } else {
                    // Op√ß√µes gen√©ricas como fallback
                    contextualOptions = [
                      { id: `${question.id}_0`, label: "Sim, definitivamente", value: `${question.id}_sim` },
                      { id: `${question.id}_1`, label: "Parcialmente", value: `${question.id}_parcial` },
                      { id: `${question.id}_2`, label: "N√£o", value: `${question.id}_nao` },
                      { id: `${question.id}_3`, label: "Pular pergunta", value: `${question.id}_pular` },
                    ];
                  }

                  dynamicPieces.push({
                    kind: "options",
                    options: contextualOptions
                  });
                }
              }
            });
          }

          // SEMPRE injetar pelo menos as perguntas b√°sicas de fallback
          if (dynamicPieces.length > 0) {
            inject(dynamicPieces);
          } else {
            // Fallback completo se n√£o conseguiu gerar perguntas
            inject([
              { kind: "text", text: "Vamos come√ßar com algumas perguntas b√°sicas.", delayMs: 400 },
              { kind: "text", text: "Pergunta 1/3 ‚Äî Qual √© o tema principal?", delayMs: 500 },
              {
                kind: "options",
                options: [
                  { id: "pergunta_1_0", label: "Neg√≥cios", value: "pergunta_1_negocios" },
                  { id: "pergunta_1_1", label: "Sa√∫de", value: "pergunta_1_saude" },
                  { id: "pergunta_1_2", label: "Fic√ß√£o", value: "pergunta_1_ficcao" },
                  { id: "pergunta_1_3", label: "Outro", value: "pergunta_1_outro" },
                ],
              },
            ]);
          }
        });
        return;
      }

      if (opt.value.startsWith("tema_")) {
        const tema = opt.label;
        setBrief((b) => ({ ...b, tema }));
        inject([
          { kind: "text", text: `Perfeito. Tema definido: ${tema}.`, delayMs: 400 },
          { kind: "text", text: "Pergunta 2/3 ‚Äî Para quem √© o livro?", delayMs: 500 },
          {
            kind: "options",
            options: [
              { id: "p1", label: "Iniciantes", value: "publico_iniciantes" },
              { id: "p2", label: "Profissionais", value: "publico_profissionais" },
              { id: "p3", label: "Pais e m√£es", value: "publico_pais" },
            ],
          },
        ]);
        return;
      }

      if (opt.value.startsWith("publico_")) {
        const publico = opt.label;
        setBrief((b) => ({ ...b, publico }));
        inject([
          { kind: "text", text: `√ìtimo. P√∫blico-alvo: ${publico}.`, delayMs: 400 },
          { kind: "text", text: "Pergunta 3/3 ‚Äî Qual o tom desejado?", delayMs: 500 },
          {
            kind: "options",
            options: [
              { id: "tm1", label: "Pr√°tico", value: "tom_pratico" },
              { id: "tm2", label: "Inspirador", value: "tom_inspirador" },
              { id: "tm3", label: "Acad√™mico", value: "tom_academico" },
            ],
          },
        ]);
        return;
      }

      if (opt.value.startsWith("tom_")) {
        const tom = opt.label;
        setBrief((b) => ({ ...b, tom }));

        inject([
          { kind: "text", text: `Perfeito. Tom definido: ${tom}.`, delayMs: 400 },
          { kind: "text", text: "Gerando um sum√°rio personalizado baseado no seu briefing...", delayMs: 500 },
        ]);

        // Gerar sum√°rio din√¢mico
        generateDynamicSummary(brief.tema || 'Tema n√£o definido', brief.publico || 'P√∫blico n√£o definido', tom).then((summary) => {
          inject([
            { kind: "text", text: "Sum√°rio gerado com IA:", delayMs: 700 },
            { kind: "text", text: summary, delayMs: 500 },
            {
              kind: "options",
              options: [
                { id: "oktoc", label: "Aprovar sum√°rio", value: "approve_toc" },
                { id: "edittoc", label: "Editar sum√°rio", value: "edit_toc" },
              ],
            },
          ]);
        });
        return;
      }

      if (opt.value === "edit_toc") {
        inject([
          { kind: "text", text: "Voc√™ pode editar o sum√°rio manualmente ou solicitar ajustes.", delayMs: 500 },
          {
            kind: "options",
            options: [
              { id: "manual", label: "Editar manualmente", value: "manual_edit" },
              { id: "ai_adjust", label: "Pedir ajuste √† IA", value: "ai_adjust" },
              { id: "approve_anyway", label: "Aprovar mesmo assim", value: "approve_toc" },
            ],
          },
        ]);
        return;
      }

      if (opt.value === "approve_toc") {
        inject([
          { kind: "text", text: "Sum√°rio aprovado! Agora vamos para o pagamento.", delayMs: 500 },
          { kind: "text", text: "Valor: R$ 97 (livro completo ~100 p√°ginas + capa)", delayMs: 600 },
          {
            kind: "options",
            options: [
              { id: "pay", label: "Pagar agora", value: "payment" },
              { id: "later", label: "Pagar depois", value: "later" },
            ],
          },
        ]);
        return;
      }

      if (opt.value === "payment") {
        inject([
          { kind: "text", text: "Redirecionando para pagamento...", delayMs: 400 },
          { kind: "text", text: "Simulando pagamento aprovado ‚úÖ", delayMs: 1200 },
          ...makeChapterBursts(12),
        ]);
        return;
      }

      if (opt.value === "manual_edit" || opt.value === "ai_adjust") {
        inject([
          { kind: "text", text: "Funcionalidade em desenvolvimento. Por enquanto, vamos aprovar o sum√°rio.", delayMs: 500 },
          {
            kind: "options",
            options: [
              { id: "approve_anyway", label: "Aprovar sum√°rio", value: "approve_toc" },
            ],
          },
        ]);
        return;
      }

      if (opt.value === "plans") {
        inject([
          { kind: "text", text: "Planos: B√°sico (R$ 97) ‚Ä¢ Pro (R$ 197, inclui revis√£o humana) ‚Ä¢ Studio (R$ 297, inclui capa premium)", delayMs: 500 },
          {
            kind: "options",
            options: [
              { id: "pay2", label: "Pagar agora (R$ 97)", value: "pay" },
            ],
          },
        ]);
        return;
      }

      if (opt.value === "pay") {
        // gerar sequ√™ncia de cap√≠tulos + capa. Substitui ${TEMA}
        const tema = brief.tema || "${tema}";
        const bursts = makeChapterBursts(10).map((p) => {
          if (p.kind === "text" && p.text.includes("${TEMA}")) {
            return { ...p, text: p.text.replace("${TEMA}", tema) } as ChatPiece;
          }
          return p;
        });
        inject(bursts);
        return;
      }
    },
    [onOptionSelect, inject, brief, continueAfterDynamicIfReady, dynamicQuestions, generateDynamicQuestions, generateDynamicSummary]
  );

  useEffect(() => {
    if (!userEcho) return;
    const timeout = setTimeout(() => {
      setUserEcho(null);
      setPlayedIndex((v) => (v < timeline.length - 1 ? v + 1 : v));
    }, 500);
    return () => clearTimeout(timeout);
  }, [userEcho, timeline.length]);

  const donePieces = useMemo(
    () =>
      timeline
        .slice(0, playedIndex)
        .filter((p) => p.kind === "text") as Extract<ChatPiece, { kind: "text" }>[],
    [playedIndex, timeline]
  );
  
  // Callback para quando o fluxo din√¢mico for conclu√≠do
  const handleFluxoComplete = useCallback((respostas: Record<string, string>) => {
    console.log('Fluxo conclu√≠do com respostas:', respostas);
    // Aqui voc√™ pode processar as respostas conforme necess√°rio
    // Por exemplo, redirecionar para pagamento, etc.
  }, []);

  // Loading state
  if (carregandoFluxo) {
    return (
      <div className="flex items-center justify-center h-full w-full">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-emerald-600 mx-auto mb-4"></div>
          <p className="text-gray-600">Carregando fluxo...</p>
        </div>
      </div>
    );
  }

  // Se h√° fluxo ativo configurado, usar FluxoDinamico
  if (fluxoAtivo && !usarFluxoEstatico) {
    return (
      <section className={`flex flex-col gap-6 py-4 px-4 h-full w-full ${className}`}>
        <div className="flex items-center justify-between mb-4">
          <h2 className="text-lg font-semibold text-gray-800">
            {fluxoAtivo.nome}
          </h2>
          <button
            onClick={() => setUsarFluxoEstatico(true)}
            className="text-sm text-gray-500 hover:text-gray-700 underline"
          >
            Usar fluxo padr√£o
          </button>
        </div>
        <FluxoDinamico 
          fluxoId={fluxoAtivo.id} 
          onComplete={handleFluxoComplete}
        />
      </section>
    );
  }

  // Fluxo est√°tico (original)
  return (
    <section
      aria-label="Conversa interativa"
      className={clsx(
        "flex flex-col gap-6 py-4 px-4 h-full w-full", // full-height
        className
      )}
    >
      {/* Conversation area */}
      <div
        ref={containerRef}
        className={`flex-1 w-full overflow-y-auto border-t border-neutral-200 bg-white p-4 md:p-6 pb-[env(safe-area-inset-bottom)]`}
      >
        <div className="mx-auto flex max-w-3xl flex-col gap-4 md:gap-5">
          {donePieces.map((piece, idx) => (
            <motion.div
              key={`done-${idx}`}
              initial={{ opacity: 0, y: 6 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ type: "spring", stiffness: 240, damping: 26, mass: 0.7 }}
            >
              <AgentRow avatarUrl={avatarUrl} bubbleMaxWidthClass={bubbleMaxWidthClass}>
                <TextBlock text={piece.text} />
              </AgentRow>
            </motion.div>
          ))}

          {currentPiece && currentPiece.kind === "text" && (
            <motion.div
              key={`typing-${playedIndex}`}
              initial={{ opacity: 0, y: 6 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ type: "spring", stiffness: 240, damping: 26, mass: 0.7 }}
            >
              <AgentRow avatarUrl={avatarUrl} bubbleMaxWidthClass={bubbleMaxWidthClass}>
                <div className="min-h-[1.5rem]">
                  {typingText ? (
                    <TextBlock text={typingText} />
                  ) : isGeneratingQuestions || isGeneratingSummary ? (
                    // Loader skeleton + texto de status
                    <div className="flex items-center gap-3">
                      <div className="h-4 w-28 animate-pulse rounded bg-neutral-200" />
                      <div className="h-4 w-36 animate-pulse rounded bg-neutral-200" />
                      <span className="text-sm text-neutral-600">
                        {isGeneratingQuestions ? "Gerando perguntas personalizadas..." : "Criando sum√°rio com IA..."}
                      </span>
                    </div>
                  ) : (
                    <TypingDots />
                  )}
                </div>
              </AgentRow>
            </motion.div>
          )}

          {/* Loader adicional quando est√° gerando algo */}
          {(isGeneratingQuestions || isGeneratingSummary) && (
            <motion.div
              key="loading-indicator"
              initial={{ opacity: 0, y: 6 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ type: "spring", stiffness: 240, damping: 26, mass: 0.7 }}
            >
              <AgentRow avatarUrl={avatarUrl} bubbleMaxWidthClass={bubbleMaxWidthClass}>
                <div className="flex items-center gap-3 py-2">
                  <div className="flex gap-1">
                    <div className="h-2 w-2 animate-pulse rounded-full bg-emerald-500" />
                    <div className="h-2 w-2 animate-pulse rounded-full bg-emerald-500 [animation-delay:0.2s]" />
                    <div className="h-2 w-2 animate-pulse rounded-full bg-emerald-500 [animation-delay:0.4s]" />
                  </div>
                  <span className="text-sm text-neutral-600">
                    {isGeneratingQuestions ? "Gerando perguntas personalizadas..." : "Criando sum√°rio com IA..."}
                  </span>
                </div>
              </AgentRow>
            </motion.div>
          )}

          {/* User echo */}
          <AnimatePresence>
            {userEcho && (
              <motion.div
                key="user-echo"
                initial={{ opacity: 0, x: 8 }}
                animate={{ opacity: 1, x: 0 }}
                exit={{ opacity: 0, x: 8 }}
                transition={{ type: "spring", stiffness: 260, damping: 22 }}
                className="ml-auto"
              >
                <div className="max-w-[80%] rounded-xl bg-emerald-600 px-3 py-2 text-white">
                  <span className="text-sm font-medium">{userEcho}</span>
                </div>
              </motion.div>
            )}
          </AnimatePresence>
        </div>

        {/* Quick replies */}
        <AnimatePresence>
          {showOptions && (
            <motion.div
              key="options"
              initial={{ opacity: 0, y: 8 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 8 }}
              transition={{ type: "spring", stiffness: 260, damping: 24 }}
              className="pointer-events-auto sticky bottom-2 mt-4 flex w-full justify-center"
            >
              <div className="mx-auto flex max-w-2xl flex-wrap items-center justify-center gap-2 rounded-full border border-neutral-200 bg-white p-2">
                {showOptions.map((opt, i) => (
                  <UIButton
                    key={opt.id}
                    ariaLabel={`Selecionar: ${opt.label}`}
                    className={clsx(
                      "min-w-[9.5rem] border-emerald-300 bg-emerald-50 text-emerald-700 hover:bg-emerald-100",
                      i === 1 && "border-emerald-600 bg-emerald-600 text-white hover:bg-emerald-700"
                    )}
                    onClick={() => handleSelect(opt)}
                  >
                    {i === 1 ? <Check className="h-4 w-4" /> : <ChevronsRight className="h-4 w-4" />}
                    {opt.label}
                  </UIButton>
                ))}
              </div>
            </motion.div>
          )}
        </AnimatePresence>

        {/* Input Text Question */}
        <AnimatePresence>
          {awaitingInput && (
            <motion.div
              key="text-input"
              initial={{ opacity: 0, y: 8 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 8 }}
              transition={{ type: "spring", stiffness: 260, damping: 24 }}
              className="pointer-events-auto sticky bottom-2 mt-4 flex w-full justify-center"
            >
              <div className="mx-auto flex max-w-2xl w-full items-center gap-3 md:gap-4 rounded-xl border border-neutral-200 bg-white p-2 md:p-3">
                <Textarea
                  value={textInputValue}
                  onChange={(e) => setTextInputValue(e.target.value)}
                  placeholder={awaitingInput === "nome" ? "Digite seu nome" :
                    awaitingInput === "titulo" ? "Ex: O Clube das 5 da Manh√£" :
                      awaitingInput === "subtitulo" ? "Ex: Como Acordar Cedo Pode Transformar sua Vida" :
                        awaitingInput === "resumo" ? "Descreva o conte√∫do do livro em detalhes..." :
                          awaitingInput === "autor" ? "Nome do autor" :
                            awaitingInput === "email" ? "seu@email.com" :
                              awaitingInput === "whatsapp" ? "11999999999" : "Digite aqui..."}
                  className="flex-1 min-h-[44px] text-sm"
                />
                <UIButton
                  ariaLabel="Enviar resposta"
                  className="border-emerald-600 bg-emerald-600 text-white hover:bg-emerald-700"
                  onClick={() => {
                    const value = textInputValue.trim();
                    if (!value) return;
                    setUserEcho(value);

                    // Script do Bruno - Capturar inputs espec√≠ficos
                    if (awaitingInput === "nome") {
                      setUserData(prev => ({ ...prev, nome: value }));
                      setAwaitingInput(null);
                      inject([
                        { kind: "text", text: `Prazer, ${value}!`, delayMs: 500 },
                        { kind: "text", text: "Voc√™ sabia que dava para ganhar tanto dinheiro vendendo ebooks na Amazon?", delayMs: 800 },
                        {
                          kind: "options",
                          options: [
                            { id: "nunca1", label: "NUNCA NEM IMAGINEI", value: "nunca_nem_imaginei" },
                            { id: "sabia1", label: "J√Å SABIA SIM", value: "ja_sabia_sim" },
                          ],
                        },
                      ]);
                    } else if (awaitingInput === "titulo") {
                      setUserData(prev => ({ ...prev, titulo: value }));
                      setAwaitingInput(null);
                      inject([
                        { kind: "text", text: "Subt√≠tulo:", delayMs: 500 },
                        { kind: "text", text: "(Ex: Como Acordar Cedo Pode Transformar sua Vida e Conduzi-lo ao Sucesso)", delayMs: 700 },
                      ]);
                      setAwaitingInput("subtitulo");
                    } else if (awaitingInput === "subtitulo") {
                      setUserData(prev => ({ ...prev, subtitulo: value }));
                      setAwaitingInput(null);
                      inject([
                        { kind: "text", text: "Um breve resumo do que voc√™ quer que tenha no conte√∫do do livro.", delayMs: 600 },
                        { kind: "text", text: "Seja rico(a) em detalhes. Quanto mais informa√ß√µes voc√™ inserir, melhor ser√° seu livro.", delayMs: 800 },
                      ]);
                      setAwaitingInput("resumo");
                    } else if (awaitingInput === "resumo") {
                      setUserData(prev => ({ ...prev, resumo: value }));
                      setAwaitingInput(null);
                      inject([
                        { kind: "text", text: "Em que idioma voc√™ quer o livro?", delayMs: 500 },
                        {
                          kind: "options",
                          options: [
                            { id: "pt1", label: "PORTUGU√äS DO BRASIL", value: "portugues" },
                            { id: "en1", label: "INGL√äS", value: "ingles" },
                          ],
                        },
                      ]);
                    } else if (awaitingInput === "autor") {
                      setUserData(prev => ({ ...prev, autor: value }));
                      setAwaitingInput(null);
                      inject([
                        { kind: "text", text: "Em que e-mail voc√™ deseja receber o livro?", delayMs: 500 },
                      ]);
                      setAwaitingInput("email");
                    } else if (awaitingInput === "email") {
                      setUserData(prev => ({ ...prev, email: value }));
                      setAwaitingInput(null);
                      inject([
                        { kind: "text", text: "Perfeito! Vamos fazer o seguinte:", delayMs: 500 },
                        { kind: "text", text: "Irei te enviar gratuitamente o seu planejamento do livro no Whatsapp e no seu email.", delayMs: 800 },
                        { kind: "text", text: "Qual seu Whatsapp?", delayMs: 600 },
                      ]);
                      setAwaitingInput("whatsapp");
                    } else if (awaitingInput === "whatsapp") {
                      setUserData(prev => ({ ...prev, whatsapp: value }));
                      setAwaitingInput(null);
                      inject([
                        { kind: "text", text: "Esses s√£o seus dados, est√£o corretos?", delayMs: 600 },
                        { kind: "text", text: `üìã Nome: ${userData.nome}`, delayMs: 500 },
                        { kind: "text", text: `üìö T√≠tulo: ${userData.titulo}`, delayMs: 500 },
                        { kind: "text", text: `üìù Subt√≠tulo: ${userData.subtitulo}`, delayMs: 500 },
                        { kind: "text", text: `üåç Idioma: ${userData.idioma}`, delayMs: 500 },
                        { kind: "text", text: `üë§ Autor: ${userData.autor}`, delayMs: 500 },
                        { kind: "text", text: `üìß Email: ${userData.email}`, delayMs: 500 },
                        { kind: "text", text: `üì± WhatsApp: ${value}`, delayMs: 500 },
                        {
                          kind: "options",
                          options: [
                            { id: "ok1", label: "Tudo certo. Vamos seguir!", value: "tudo_certo" },
                            { id: "erro1", label: "Ops, tem um erro no meu contato", value: "tem_erro" },
                          ],
                        },
                      ]);
                    }

                    setTextInputValue("");
                  }}
                >
                  Enviar
                </UIButton>
                <UIButton
                  ariaLabel="Pular pergunta"
                  className="border-neutral-300 bg-white text-neutral-700 hover:bg-neutral-100"
                  onClick={() => {
                    // Registrar como pulada sem valor
                    if (awaitingTextQuestion) {
                      setDynamicAnswers((prev) => ({ ...prev, [awaitingTextQuestion.id]: "" }));
                    }
                    setTextInputValue("");
                    setAwaitingTextQuestion(null);
                    inject([{ kind: 'text', text: 'Pergunta pulada. Tudo bem, vamos em frente.', delayMs: 300 }]);
                    if (!promptNextUnansweredTextQuestion()) {
                      continueAfterDynamicIfReady();
                    }
                  }}
                >
                  Pular pergunta
                </UIButton>
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      </div>
    </section>
  );
}

// ---------- Dev‚Äëonly sanity tests ----------
// Rodam apenas no navegador e fora de produ√ß√£o, n√£o afetam o usu√°rio final.
if (typeof window !== "undefined" && process.env.NODE_ENV !== "production") {
  (window as unknown as { __CHAT_DEV_TESTED__: boolean }).__CHAT_DEV_TESTED__ = true;

  // Teste 1: splitLines deve dividir por \n e \r\n
  console.assert(
    JSON.stringify(splitLines("a\nb\nc")) === JSON.stringify(["a", "b", "c"]),
    "splitLines n√£o dividiu por \n corretamente"
  );
  console.assert(
    JSON.stringify(splitLines("a\r\nb\r\nc")) === JSON.stringify(["a", "b", "c"]),
    "splitLines n√£o dividiu por \r\n corretamente"
  );

  // Teste 2: makeToc deve conter 12 itens e manter quebras
  const toc = makeToc({ tema: "Neg√≥cios", publico: "Iniciantes", tom: "Pr√°tico" });
  const tocLines = splitLines(toc);
  console.assert(
    toc.includes("Sum√°rio sugerido"),
    "makeToc n√£o gerou cabe√ßalho do sum√°rio"
  );
  console.assert(
    tocLines.length >= 12,
    "makeToc deveria ter ao menos 12 linhas (cap√≠tulos)"
  );
}
